/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package MultibandImage;

import LearnJavaImageProcessing.SixBands;
import java.awt.Color;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Random;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.DoubleStream;
import java.util.stream.IntStream;
import java.util.stream.Stream;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import javax.swing.JFileChooser;
import javax.swing.JFormattedTextField;

/**
 *
 * @author Nadian
 */
public class ImageBandsProcess extends javax.swing.JFrame {

    
    /**
     * Creates new form ImageBandsProcess
     */
    public ImageBandsProcess() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1_ = new javax.swing.JPanel();
        jLabel_band1 = new javax.swing.JLabel();
        jLabel_band2 = new javax.swing.JLabel();
        jLabel_band3 = new javax.swing.JLabel();
        jLabel_band4 = new javax.swing.JLabel();
        jLabel_band5 = new javax.swing.JLabel();
        jLabel_band6 = new javax.swing.JLabel();
        jButton_process = new javax.swing.JButton();
        jButton_load = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jTextField_kluster = new javax.swing.JTextField();
        jLabel_result = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Image Bands Processing");
        setBackground(java.awt.Color.white);
        setForeground(new java.awt.Color(0, 153, 153));

        jPanel1_.setBackground(java.awt.Color.white);

        jLabel_band1.setText("Band 1");
        jLabel_band1.setBorder(javax.swing.BorderFactory.createEtchedBorder(new java.awt.Color(153, 204, 255), new java.awt.Color(204, 204, 255)));

        jLabel_band2.setText("Band 2");
        jLabel_band2.setBorder(javax.swing.BorderFactory.createEtchedBorder(new java.awt.Color(153, 204, 255), new java.awt.Color(204, 204, 255)));

        jLabel_band3.setText("Band 3");
        jLabel_band3.setBorder(javax.swing.BorderFactory.createEtchedBorder(new java.awt.Color(153, 204, 255), new java.awt.Color(204, 204, 255)));

        jLabel_band4.setText("Band 4");
        jLabel_band4.setBorder(javax.swing.BorderFactory.createEtchedBorder(new java.awt.Color(153, 204, 255), new java.awt.Color(204, 204, 255)));

        jLabel_band5.setText("Band 5");
        jLabel_band5.setBorder(javax.swing.BorderFactory.createEtchedBorder(new java.awt.Color(153, 204, 255), new java.awt.Color(204, 204, 255)));

        jLabel_band6.setText("Band 6");
        jLabel_band6.setBorder(javax.swing.BorderFactory.createEtchedBorder(new java.awt.Color(153, 204, 255), new java.awt.Color(204, 204, 255)));

        jButton_process.setText("Proses");
        jButton_process.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton_processActionPerformed(evt);
            }
        });

        jButton_load.setBackground(java.awt.Color.white);
        jButton_load.setFont(new java.awt.Font("Tahoma", 0, 12)); // NOI18N
        jButton_load.setText("Load Image Bands");
        jButton_load.setToolTipText("Input File Image Bands");
        jButton_load.setBorderPainted(false);
        jButton_load.setFocusable(false);
        jButton_load.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButton_load.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jButton_load.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton_loadActionPerformed(evt);
            }
        });

        jLabel1.setText("Banyak Cluster :");

        jTextField_kluster.setText("5");
        jTextField_kluster.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jTextField_klusterActionPerformed(evt);
            }
        });
        jTextField_kluster.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyTyped(java.awt.event.KeyEvent evt) {
                jTextField_klusterKeyTyped(evt);
            }
        });

        jLabel_result.setText("jLabel2");
        jLabel_result.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));

        javax.swing.GroupLayout jPanel1_Layout = new javax.swing.GroupLayout(jPanel1_);
        jPanel1_.setLayout(jPanel1_Layout);
        jPanel1_Layout.setHorizontalGroup(
            jPanel1_Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1_Layout.createSequentialGroup()
                .addGap(18, 18, 18)
                .addGroup(jPanel1_Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jButton_load)
                    .addGroup(jPanel1_Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                        .addGroup(javax.swing.GroupLayout.Alignment.LEADING, jPanel1_Layout.createSequentialGroup()
                            .addComponent(jLabel1)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(jTextField_kluster, javax.swing.GroupLayout.PREFERRED_SIZE, 87, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(jButton_process)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jLabel_result, javax.swing.GroupLayout.PREFERRED_SIZE, 190, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGroup(javax.swing.GroupLayout.Alignment.LEADING, jPanel1_Layout.createSequentialGroup()
                            .addComponent(jLabel_band1, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(jLabel_band2, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(jLabel_band3, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(jLabel_band4, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(jLabel_band5, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(jLabel_band6, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE))))
                .addContainerGap(22, Short.MAX_VALUE))
        );
        jPanel1_Layout.setVerticalGroup(
            jPanel1_Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1_Layout.createSequentialGroup()
                .addGap(24, 24, 24)
                .addComponent(jButton_load)
                .addGap(27, 27, 27)
                .addGroup(jPanel1_Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel_band1, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel_band2, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel_band3, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel_band4, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel_band5, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel_band6, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGroup(jPanel1_Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1_Layout.createSequentialGroup()
                        .addGap(27, 27, 27)
                        .addGroup(jPanel1_Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel1)
                            .addComponent(jTextField_kluster, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jButton_process, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addGroup(jPanel1_Layout.createSequentialGroup()
                        .addGap(32, 32, 32)
                        .addComponent(jLabel_result, javax.swing.GroupLayout.PREFERRED_SIZE, 190, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(30, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1_, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1_, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents
    
    private static ArrayList<BandImage> bandImages = new ArrayList<>();
    private static ArrayList<Point> trainingPoints = new ArrayList<>();
    private static ArrayList<Point> centroid = new ArrayList<>();
    private static ArrayList<Color> colorKluster = new ArrayList<>();
    
    static int locHeight, locWidth;
    static int k;
    private static double[][] cArrayDistances = new double[locHeight*locWidth][locHeight*locWidth]; //prepare matriks jarak
    
    
    private void jButton_loadActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton_loadActionPerformed
        // choosing multiple bands
        JFileChooser chooser = new JFileChooser();
        chooser.setMultiSelectionEnabled(true);
        chooser.showOpenDialog(null);
        
        File[] f = chooser.getSelectedFiles();
        
        String[] filenames = new String[f.length];  //array of path
        File[] files = f;  //files that contain each path 
        BufferedImage[] buffImages = new BufferedImage[f.length];   //aray of buffimages
        ImageIcon[] icons = new ImageIcon[f.length]; //array og imageicon that will displayed on GUI
        int count=0;
        
        for(File file : f ){
            filenames[count] = file.getAbsolutePath();  //assign array of path
            files[count] = new File(filenames[count]);  //make array of file taht contain each path file
            try {
                buffImages[count] = ImageIO.read(files[count]); //read and turn into BufferedImage
            } catch (IOException ex) {
                Logger.getLogger(SixBands.class.getName()).log(Level.SEVERE, null, ex);
            }
            icons[count] = new ImageIcon(buffImages[count].getScaledInstance(145, 145, 145)); //turn BufferedImages into ImageIcon
            //---------------1. Loading band image 1-nBand masukkan arraylist of BandImage //2. loading band image 2
            //preparing instances (loadBands)
            BandImage newBand = new BandImage(files[count]);
            bandImages.add(newBand);
            count++;
        }
        System.out.println("=> banyak array list bandimage : " + bandImages.size());
        setIntoGUI(icons);  
    }//GEN-LAST:event_jButton_loadActionPerformed

    private void jButton_processActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton_processActionPerformed
        if(!bandImages.isEmpty()){
            locHeight = bandImages.get(0).getHeight(); //ukuran gambar
            locWidth = bandImages.get(0).getWidth(); //ukuran gambar
        }
        //---------------2. generate data set from 6 band (indexes)
        //out : trainingPoints terisi, centroid terisi (array of point that called centroid of training set)
        if(locHeight!=0 && locWidth!=0)
            initDataPoint(locHeight, locWidth);     //initial trainingPoints
        if(!trainingPoints.isEmpty())
            initLabelCentroid(trainingPoints);
        System.out.println("2. Data Set From 6 Bands LOADED : trainingPoints, initial centroid");
        
        //-- additional : EQUIPMENTS CHECKS
        //mencetak trainingpoints dan inisial centroid didapat
        System.out.println("=> trainingPoints LOADED");
        //printPointData(trainingPoints);
        System.out.println("------------------------ jumlah trainingPoints: " + trainingPoints.size());
        System.out.println("=> centroid LOADED");
        //printPointData(centroid);
        System.out.println("------------------------ jumlah centroid: " + centroid.size());
        
        //---------------3. tentukan k
        k = Integer.parseInt(jTextField_kluster.getText());
        
        while(centroid.size()>k){
            //DO THE HIRARCHICAL CLUSTERING ALGORITHM
            //---------------4. hitung jarak, buat matriksnya [matriks jarak]
            makeCentArrayDistances();
            
            //---------------5. cari angka minimum dari matriks jarak
            double minDistance = getMinValueOf2DDouble(cArrayDistances);
            System.out.println("5. Tentukan Jarak minimum: " +minDistance);
            
            //---------------6. cari index dari angka minimum matriks jarak
            int[] indexOfMinDistance = getIndexOf2D(cArrayDistances, minDistance); //3. mencari index (2 kluster terdekat) dari nilai minimum jarak centroid
            System.out.println("=> index Merge (Cluster that will be merged) : " + indexOfMinDistance[0] +"  --and-- "+indexOfMinDistance[1]);

            //---------------7. Gabungkan 2 Kluster yang terdekat
            centroid = doMergeCluster(centroid, indexOfMinDistance);
            //---------------8. Update data set dengan label kluster yang baru
            trainingPoints = rearrangeLabelCentroid(trainingPoints, indexOfMinDistance);
            
            //---------------9. Cetak Data dengan LABEL updated
            System.out.println("=> Data Training IRIS after arrange :");
//            printPointData(trainingPoints);
            //printPointDataLabelOnly(trainingPoints); //HASIL PELABELAN ONLY
            System.out.println("\n==============="+centroid.size()+"===============\n\n");
        }
        printPointData(trainingPoints); // trainingPoints adalah daata dg label tekluster sebanyak k
        //printPointDataLabelOnly(trainingPoints);

        //RESULT preparation
        colorKluster = getDistinctColor(k);
        BufferedImage bimage = new BufferedImage(locHeight, locWidth, BufferedImage.TYPE_INT_ARGB);
        bimage = buildImageResult(locHeight,locWidth,k);
        
        showInJFrame(bimage);
    }//GEN-LAST:event_jButton_processActionPerformed

    private void jTextField_klusterActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jTextField_klusterActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_jTextField_klusterActionPerformed

    private void jTextField_klusterKeyTyped(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jTextField_klusterKeyTyped
        // TODO add your handling code here:
        char enter = evt.getKeyChar();
        if(!(Character.isDigit(enter))){
            evt.consume();
        }
    }//GEN-LAST:event_jTextField_klusterKeyTyped

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(ImageBandsProcess.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(ImageBandsProcess.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(ImageBandsProcess.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(ImageBandsProcess.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new ImageBandsProcess().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton_load;
    private javax.swing.JButton jButton_process;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel_band1;
    private javax.swing.JLabel jLabel_band2;
    private javax.swing.JLabel jLabel_band3;
    private javax.swing.JLabel jLabel_band4;
    private javax.swing.JLabel jLabel_band5;
    private javax.swing.JLabel jLabel_band6;
    private javax.swing.JLabel jLabel_result;
    private javax.swing.JPanel jPanel1_;
    private javax.swing.JTextField jTextField_kluster;
    // End of variables declaration//GEN-END:variables

    private void setIntoGUI(ImageIcon[] imgIcons) {
        if(imgIcons[0]!=null){
            jLabel_band1.setIcon(imgIcons[0]);
        }
        if(imgIcons[1]!=null){
            jLabel_band2.setIcon(imgIcons[1]);
        }
        if(imgIcons[2]!=null){
            jLabel_band3.setIcon(imgIcons[2]);
        }
        if(imgIcons[3]!=null){
            jLabel_band4.setIcon(imgIcons[3]);
        }
        if(imgIcons[4]!=null){
            jLabel_band5.setIcon(imgIcons[4]);
        }
        if(imgIcons[5]!=null){
            jLabel_band6.setIcon(imgIcons[5]);
        }
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    private void initDataPoint(int height, int width) {
        if(!bandImages.isEmpty()){
            for(int i=0 ; i< height ; i++){
              for(int j=0 ; j< width ; j++){
                  //System.out.println("data "+i+" "+ j);
                  int[] datas = new int[bandImages.size()];
                  for(int n=0 ; n<bandImages.size();n++){
                      int[][] temp = bandImages.get(n).getGrayscale(); //band ke n diambil matrik grayscalenya
                      //System.out.print(temp[i][j]+ " ");
                      datas[n] = temp[i][j];                  
                  }
//                  System.out.println("datas : "+datas[0]+" " +datas[1]+" " +datas[2] +" " +datas[3]+" " +datas[4]+" " +datas[5] );
//                  System.out.println(" ");
                  Point trainpoint = new Point(datas); //ada sebanyak 32*32 data training terbentuk
                  //System.out.println("trainpoint "+ trainpoint.getmIndex()[0]+ " "+trainpoint.getmIndex()[1]+ " "+trainpoint.getmIndex()[2]+ " "+trainpoint.getmIndex()[3]);
                  trainingPoints.add(trainpoint);
                  centroid.add(new Point(datas));
                 
                  //int[] index = new int[2] {i,j}; 
                  //getDistance(index)
              }
            }
            if(!trainingPoints.isEmpty())
                System.out.println("Training Points have loaded SUCCESSFULLY");
            else
                System.out.println("Cannt load Training Points yet :(");
            if(!centroid.isEmpty())
                System.out.println("Arraylist Centroid have loaded SUCCESSFULLY");
            else
                System.out.println("Cannt load Arraylist of Centroid yet :(");
        }else
            System.out.println("So saad, Band Images Belum terload");
    }

    private void initLabelCentroid(ArrayList<Point> Points) {
        for(int i=0 ; i < Points.size() ; i++){
            Points.get(i).setmLabel(i);
        }
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }
    
    private static void printPointData(ArrayList<Point> Points) {
        int counter=0;
        for (Point point : Points) {        //print datatraining
            int[] tempIndex = new int[point.getmIndex().length];
            tempIndex = point.getmIndex();
            System.out.println(+counter+"---> "+  Arrays.toString(tempIndex) + " label: "+ point.getmLabel());
            counter++;
        }
    }

    private void makeCentArrayDistances() {
        cArrayDistances = new double[centroid.size()][centroid.size()];
        Point dist = new Point();
        System.out.println("=> (Matriks) Array of Distance: ");
        for(int i=0; i<centroid.size() ; i++){
            int[] iIndex = centroid.get(i).getmIndex();
//            for(int j=0; j<(i+1) ; j++){
            for(int j=0; j<(centroid.size()) ; j++){
                int[] tempIndex = new int[bandImages.size()];
                int[] jIndex = centroid.get(j).getmIndex();
                double tempcArrayDistance =0;
                for(int k=0; k<bandImages.size() ;k++){
                    //System.out.println(iIndex[k]+" - "+ jIndex[k]);
                    tempIndex[k] = iIndex[k]-jIndex[k];
                    //System.out.print(" "+tempIndex[k]);
                    tempcArrayDistance += Math.pow(tempIndex[k],2);
                }
                //System.out.println(" ");
                dist.setmIndex(tempIndex);
                //System.out.println(tempcArrayDistance);
                if(i==j)
                    cArrayDistances[i][j] = 999;
                else
                    cArrayDistances[i][j] = Math.sqrt(tempcArrayDistance);
                //System.out.print(formatter.format(cArrayDistances[i][j]) + " ");
            }
            //System.out.println(" ");
        }
        System.out.println("4. Matriks Jarak dari "+centroid.size()+" centroid LOADED");
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    private double getMinValueOf2DDouble(double[][] Array) {
        Stream<double[]> temp = Stream.of(Array);
        DoubleStream Stream = temp.flatMapToDouble(x -> Arrays.stream(x)); // Cant print Stream<int[]> directly, convert / flat it to IntStream 
        double mMinDistance = Stream.min().getAsDouble();
        return mMinDistance;
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    private int[] getIndexOf2D(double[][] array2D, double value) {
        int[] var = new int[2];
        for(int i=0; i<array2D.length ; i++){
            //System.out.println(array2D.length);
//            for(int j=0; j < (i+1) ; j++){
            for(int j=0; j < (array2D.length) ; j++){
                if(array2D[i][j] == value){
                    var[0]=i;
                    var[1]=j;
                    break;
                }
            }
        }
        return var; 
    }

    private static ArrayList<Point> doMergeCluster(ArrayList<Point> mCentroid, int[] varMerge) {
        IntStream stream = Stream.of(varMerge).flatMapToInt(x -> Arrays.stream(x));
            int min = stream.min().getAsInt();
            IntStream stream2 = Stream.of(varMerge).flatMapToInt(x -> Arrays.stream(x));
            int max = stream2.max().getAsInt();
            //System.out.println(min);
        
            
            int[] minIndex, maxIndex, tempIndex;
            tempIndex = new int[bandImages.size()];
            minIndex = mCentroid.get(min).getmIndex();
            maxIndex = mCentroid.get(max).getmIndex();
            //preparing new point of merged cluster
            Point dist = new Point();
            for(int i=0; i<bandImages.size() ; i++){
                tempIndex[i] = (int) (0.5 * (minIndex[i]+maxIndex[i]));
            }
            
            dist = new Point(tempIndex);
        //merge max indexed value into min indexed value
            //System.out.println("BEFORE");
            //System.out.println("=> min index: "+ min +" "+ Arrays.toString(mCentroid.get(min).getmIndex()));
            //System.out.println("=> max index: "+ max +" "+ Arrays.toString(mCentroid.get(max).getmIndex()));
            mCentroid.set(min, dist);
            mCentroid.remove(max);
            //System.out.println("BEFORE");
            //System.out.println("=> min index: "+ min +" "+ Arrays.toString(mCentroid.get(min).getmIndex()));
            //System.out.println("=> max index: "+ max +" "+ Arrays.toString(mCentroid.get(max).getmIndex()));
            return mCentroid;
    }

    private static ArrayList<Point> rearrangeLabelCentroid(ArrayList<Point> points, int[] var) {
        int max = Arrays.stream(var).max().getAsInt();
        int min = Arrays.stream(var).min().getAsInt();  
        //System.out.println("BEFORE");
        //System.out.println("=>label min: "+ points.get(min).getmLabel());
        //System.out.println("=>label max: "+ points.get(max).getmLabel());
        for(int i=0 ; i < points.size() ; i++){
            if(points.get(i).getmLabel() == max){ //label max dimerge menjadi label min
                points.get(i).setmLabel(min);
            }else if(points.get(i).getmLabel() > max && (min != max )){ //label di atas max, dikurang 1, mengikuti jumlah centroid now
                int tempLabel = points.get(i).getmLabel();
                points.get(i).setmLabel(tempLabel-1);
            }
        }
        //System.out.println("AFTER");
        //System.out.println("=>label min: "+ points.get(min).getmLabel());
        //System.out.println("=>label max: "+ points.get(max).getmLabel());
         return points;        
    }

    private static ArrayList<Color> getDistinctColor(int klstr) {
        Random rand = new Random();
        ArrayList<Color> colorKlusters = new ArrayList<>();
        Color distinctColor = new Color(0,0,0);
        while(colorKlusters.size()<klstr ){
            int r = rand.nextInt(256);
            int g = rand.nextInt(256);
            int b = rand.nextInt(256);
            Color newColor = new Color(r,g,b);
            if(distinctColor.getRGB()!=newColor.getRGB()){
                distinctColor = newColor;
                System.out.println(colorKlusters.size()+"distinctColor : "+ r + " " + g + " " + b );
                colorKlusters.add(distinctColor);
            }else System.out.println("Ooops");
        }
        return colorKlusters;
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }
    
    private static BufferedImage buildImageResult(int height, int width, int kluster) {
        int count=0;
        BufferedImage bimage = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
        for(int i=0 ; i<height ; i++){
                for(int j=0 ; j<width ; j++){
                    for(int k=0 ; k<kluster;k++){
                        if(trainingPoints.get(i*width+j*1).getmLabel()==k){
                            Color newColor = colorKluster.get(k);
                            bimage.setRGB(j, i, newColor.getRGB());
                            System.out.println("S.No: "+ count + " Red: "+ newColor.getRed()+ " Green: "+ newColor.getGreen() +" Blue: "+ newColor.getBlue());
                        }
                    } 
                }
            }
        return bimage;
        //throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    private void showInJFrame(BufferedImage buffImage) {
        ImageIcon icon = new ImageIcon(buffImage.getScaledInstance(190, 190, 190)); 
        jLabel_result.setIcon(icon);
    }
}
